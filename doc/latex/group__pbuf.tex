\hypertarget{group__pbuf}{}\doxysection{Packet buffers (P\+B\+UF)}
\label{group__pbuf}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{group__pbuf_gaee1baa59bb2f85ba575b5a8619ac1ebf}{pbuf\+\_\+layer}} \{ \newline
\mbox{\hyperlink{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa2ded3594a3977f8bf9cf09552be327b5}{P\+B\+U\+F\+\_\+\+T\+R\+A\+N\+S\+P\+O\+RT}}, 
\mbox{\hyperlink{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfafcc1e506061ba69dfa142eb6b3da5f13}{P\+B\+U\+F\+\_\+\+IP}}, 
\mbox{\hyperlink{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfab4de441e737330558b609a990cd17346}{P\+B\+U\+F\+\_\+\+L\+I\+NK}}, 
\mbox{\hyperlink{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa0ff039585f05f9208bcb66c2d37783e2}{P\+B\+U\+F\+\_\+\+R\+A\+W\+\_\+\+TX}}, 
\newline
\mbox{\hyperlink{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa21116654fbab6d5a4dfeb87a1bb8f0ba}{P\+B\+U\+F\+\_\+\+R\+AW}}
 \}
\item 
enum \mbox{\hyperlink{group__pbuf_gab7e0e32fcc292c0d7107721766ed92fb}{pbuf\+\_\+type}} \{ \mbox{\hyperlink{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac5e9f28455bca98944a030d4b84ecfab}{P\+B\+U\+F\+\_\+\+R\+AM}}, 
\mbox{\hyperlink{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac120b0fe39efe35bb682e4aa3b82e2c9}{P\+B\+U\+F\+\_\+\+R\+OM}}, 
\mbox{\hyperlink{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac9b6ba960fdea6f2e8f35c8313b77e4e}{P\+B\+U\+F\+\_\+\+R\+EF}}, 
\mbox{\hyperlink{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbae969347127387b9b59a23ccd24b76d21}{P\+B\+U\+F\+\_\+\+P\+O\+OL}}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$ \mbox{\hyperlink{group__pbuf_gacfcb0a2af918658ba0afe36499c65f47}{pbuf\+\_\+alloc}} (\mbox{\hyperlink{group__pbuf_gaee1baa59bb2f85ba575b5a8619ac1ebf}{pbuf\+\_\+layer}} layer, u16\+\_\+t length, \mbox{\hyperlink{group__pbuf_gab7e0e32fcc292c0d7107721766ed92fb}{pbuf\+\_\+type}} type)
\item 
void \mbox{\hyperlink{group__pbuf_ga50abfe830a33a1a47a562febee66015d}{pbuf\+\_\+realloc}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p, u16\+\_\+t new\+\_\+len)
\item 
u8\+\_\+t \mbox{\hyperlink{group__pbuf_gab0dd696fb4b6bc65e548944584f1738b}{pbuf\+\_\+free}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p)
\item 
void \mbox{\hyperlink{group__pbuf_ga77f6bbd69e45e542014d9c547c7da74e}{pbuf\+\_\+ref}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p)
\item 
void \mbox{\hyperlink{group__pbuf_ga82429084fe29015509c9b4a072707cd4}{pbuf\+\_\+cat}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$h, struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$t)
\item 
void \mbox{\hyperlink{group__pbuf_ga831c9a72bda1d3bd4c7b96f5a0e3b891}{pbuf\+\_\+chain}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$h, struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$t)
\item 
\mbox{\hyperlink{group__infrastructure__errors_gaf02d9da80fd66b4f986d2c53d7231ddb}{err\+\_\+t}} \mbox{\hyperlink{group__pbuf_gaba88511dee3df4b631fde691f421320d}{pbuf\+\_\+copy}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p\+\_\+to, const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p\+\_\+from)
\item 
u16\+\_\+t \mbox{\hyperlink{group__pbuf_gac2f1f58fd36042e82af46f5015720899}{pbuf\+\_\+copy\+\_\+partial}} (const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$buf, void $\ast$dataptr, u16\+\_\+t len, u16\+\_\+t offset)
\item 
struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$ \mbox{\hyperlink{group__pbuf_ga6a961522d81f0327aaf4d4ee6d96c583}{pbuf\+\_\+skip}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$in, u16\+\_\+t in\+\_\+offset, u16\+\_\+t $\ast$out\+\_\+offset)
\item 
\mbox{\hyperlink{group__infrastructure__errors_gaf02d9da80fd66b4f986d2c53d7231ddb}{err\+\_\+t}} \mbox{\hyperlink{group__pbuf_gad1e31e370271335b197272af2724ca85}{pbuf\+\_\+take}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$buf, const void $\ast$dataptr, u16\+\_\+t len)
\item 
\mbox{\hyperlink{group__infrastructure__errors_gaf02d9da80fd66b4f986d2c53d7231ddb}{err\+\_\+t}} \mbox{\hyperlink{group__pbuf_gae1cf2bf7454ff87ff377b0b2262f9b44}{pbuf\+\_\+take\+\_\+at}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$buf, const void $\ast$dataptr, u16\+\_\+t len, u16\+\_\+t offset)
\item 
struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$ \mbox{\hyperlink{group__pbuf_ga54ac7b116c6f53c704cbf74f35a8b35c}{pbuf\+\_\+coalesce}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p, \mbox{\hyperlink{group__pbuf_gaee1baa59bb2f85ba575b5a8619ac1ebf}{pbuf\+\_\+layer}} layer)
\item 
u8\+\_\+t \mbox{\hyperlink{group__pbuf_ga6d803d9945bffb7ad97743f2fa503da6}{pbuf\+\_\+get\+\_\+at}} (const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p, u16\+\_\+t offset)
\item 
int \mbox{\hyperlink{group__pbuf_ga839f342803b0cf89049744124c5a98ad}{pbuf\+\_\+try\+\_\+get\+\_\+at}} (const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p, u16\+\_\+t offset)
\item 
void \mbox{\hyperlink{group__pbuf_gaf76863707dc02993eae116574b1ea03f}{pbuf\+\_\+put\+\_\+at}} (struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p, u16\+\_\+t offset, u8\+\_\+t data)
\item 
u16\+\_\+t \mbox{\hyperlink{group__pbuf_ga2170ccbbb13238380dbb203ee1b85974}{pbuf\+\_\+memcmp}} (const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p, u16\+\_\+t offset, const void $\ast$s2, u16\+\_\+t n)
\item 
u16\+\_\+t \mbox{\hyperlink{group__pbuf_ga18c164a6e4a24d89ea9eb7571a886448}{pbuf\+\_\+memfind}} (const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$p, const void $\ast$\mbox{\hyperlink{structmem}{mem}}, u16\+\_\+t mem\+\_\+len, u16\+\_\+t start\+\_\+offset)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Packets are built from the pbuf data structure. It supports dynamic memory allocation for packet contents or can reference externally managed packet contents both in R\+AM and R\+OM. Quick allocation for incoming packets is provided through pools with fixed sized pbufs.

A packet may span over multiple pbufs, chained as a singly linked list. This is called a \char`\"{}pbuf chain\char`\"{}.

Multiple packets may be queued, also using this singly linked list. This is called a \char`\"{}packet queue\char`\"{}.

So, a packet queue consists of one or more pbuf chains, each of which consist of one or more pbufs. C\+U\+R\+R\+E\+N\+T\+LY, P\+A\+C\+K\+ET Q\+U\+E\+U\+ES A\+RE N\+OT S\+U\+P\+P\+O\+R\+T\+E\+D!!! Use helper structs to queue multiple packets.

The differences between a pbuf chain and a packet queue are very precise but subtle.

The last pbuf of a packet has a -\/$>$tot\+\_\+len field that equals the -\/$>$len field. It can be found by traversing the list. If the last pbuf of a packet has a -\/$>$next field other than N\+U\+LL, more packets are on the queue.

Therefore, looping through a pbuf of a single packet, has an loop end condition (tot\+\_\+len == p-\/$>$len), N\+OT (next == N\+U\+LL).

Example of custom pbuf usage for zero-\/copy RX\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} \textcolor{keyword}{struct }my\_custom\_pbuf}
\DoxyCodeLine{\{}
\DoxyCodeLine{   \textcolor{keyword}{struct }pbuf\_custom p;}
\DoxyCodeLine{   \textcolor{keywordtype}{void}* dma\_descriptor;}
\DoxyCodeLine{\} my\_custom\_pbuf\_t;}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{group__mempool_ga5b1fb3ce7942432d87cc948b1c5ed6cb}{LWIP\_MEMPOOL\_DECLARE}}(RX\_POOL, 10, \textcolor{keyword}{sizeof}(my\_custom\_pbuf\_t), \textcolor{stringliteral}{"Zero-\/copy RX PBUF pool"});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} my\_pbuf\_free\_custom(\textcolor{keywordtype}{void}* p)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  my\_custom\_pbuf\_t* my\_puf = (my\_custom\_pbuf\_t*)p;}
\DoxyCodeLine{}
\DoxyCodeLine{  LOCK\_INTERRUPTS();}
\DoxyCodeLine{  free\_rx\_dma\_descriptor(my\_pbuf-\/>dma\_descriptor);}
\DoxyCodeLine{  \mbox{\hyperlink{group__mempool_gaa43d114dd702fbd8f1db18474ea93a04}{LWIP\_MEMPOOL\_FREE}}(RX\_POOL, my\_pbuf);}
\DoxyCodeLine{  UNLOCK\_INTERRUPTS();}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} eth\_rx\_irq()}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dma\_descriptor*   dma\_desc = get\_RX\_DMA\_descriptor\_from\_ethernet();}
\DoxyCodeLine{  my\_custom\_pbuf\_t* my\_pbuf  = (my\_custom\_pbuf\_t*)\mbox{\hyperlink{group__mempool_ga5e2498f6c17746c1fe7153de5f7f275a}{LWIP\_MEMPOOL\_ALLOC}}(RX\_POOL);}
\DoxyCodeLine{}
\DoxyCodeLine{  my\_pbuf-\/>p.custom\_free\_function = my\_pbuf\_free\_custom;}
\DoxyCodeLine{  my\_pbuf-\/>dma\_descriptor         = dma\_desc;}
\DoxyCodeLine{}
\DoxyCodeLine{  invalidate\_cpu\_cache(dma\_desc-\/>rx\_data, dma\_desc-\/>rx\_length);}
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{keyword}{struct }\mbox{\hyperlink{structpbuf}{pbuf}}* p = pbuf\_alloced\_custom(\mbox{\hyperlink{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa21116654fbab6d5a4dfeb87a1bb8f0ba}{PBUF\_RAW}},}
\DoxyCodeLine{     dma\_desc-\/>rx\_length,}
\DoxyCodeLine{     \mbox{\hyperlink{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac9b6ba960fdea6f2e8f35c8313b77e4e}{PBUF\_REF}},}
\DoxyCodeLine{     \&my\_pbuf-\/>p,}
\DoxyCodeLine{     dma\_desc-\/>rx\_data,}
\DoxyCodeLine{     dma\_desc-\/>max\_buffer\_size);}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{if}(\mbox{\hyperlink{structnetif}{netif}}-\/>\mbox{\hyperlink{structnetif_a8aaf0d8a095fbd84aa1a38998f039190}{input}}(p, \mbox{\hyperlink{structnetif}{netif}}) != \mbox{\hyperlink{group__infrastructure__errors_ggae2e66c7d13afc90ffecd6151680fbadcaa26c163b80b1f6786ca81dadc14b00fb}{ERR\_OK}}) \{}
\DoxyCodeLine{    \mbox{\hyperlink{group__pbuf_gab0dd696fb4b6bc65e548944584f1738b}{pbuf\_free}}(p);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}
\end{DoxyCode}
 

\doxysubsection{Enumeration Type Documentation}
\mbox{\Hypertarget{group__pbuf_gaee1baa59bb2f85ba575b5a8619ac1ebf}\label{group__pbuf_gaee1baa59bb2f85ba575b5a8619ac1ebf}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_layer@{pbuf\_layer}}
\index{pbuf\_layer@{pbuf\_layer}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_layer}{pbuf\_layer}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__pbuf_gaee1baa59bb2f85ba575b5a8619ac1ebf}{pbuf\+\_\+layer}}}

Enumeration of pbuf layers \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{PBUF\_TRANSPORT@{PBUF\_TRANSPORT}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!PBUF\_TRANSPORT@{PBUF\_TRANSPORT}}}\mbox{\Hypertarget{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa2ded3594a3977f8bf9cf09552be327b5}\label{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa2ded3594a3977f8bf9cf09552be327b5}} 
P\+B\+U\+F\+\_\+\+T\+R\+A\+N\+S\+P\+O\+RT&Includes spare room for transport layer header, e.\+g. U\+DP header. Use this if you intend to pass the pbuf to functions like udp\+\_\+send(). \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PBUF\_IP@{PBUF\_IP}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!PBUF\_IP@{PBUF\_IP}}}\mbox{\Hypertarget{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfafcc1e506061ba69dfa142eb6b3da5f13}\label{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfafcc1e506061ba69dfa142eb6b3da5f13}} 
P\+B\+U\+F\+\_\+\+IP&Includes spare room for IP header. Use this if you intend to pass the pbuf to functions like raw\+\_\+send(). \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PBUF\_LINK@{PBUF\_LINK}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!PBUF\_LINK@{PBUF\_LINK}}}\mbox{\Hypertarget{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfab4de441e737330558b609a990cd17346}\label{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfab4de441e737330558b609a990cd17346}} 
P\+B\+U\+F\+\_\+\+L\+I\+NK&Includes spare room for link layer header (ethernet header). Use this if you intend to pass the pbuf to functions like ethernet\+\_\+output(). \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group__lwip__opts__pbuf_ga35998a3d56af9940e6a80bb372597685}{P\+B\+U\+F\+\_\+\+L\+I\+N\+K\+\_\+\+H\+L\+EN}} 
\end{DoxySeeAlso}
\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PBUF\_RAW\_TX@{PBUF\_RAW\_TX}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!PBUF\_RAW\_TX@{PBUF\_RAW\_TX}}}\mbox{\Hypertarget{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa0ff039585f05f9208bcb66c2d37783e2}\label{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa0ff039585f05f9208bcb66c2d37783e2}} 
P\+B\+U\+F\+\_\+\+R\+A\+W\+\_\+\+TX&Includes spare room for additional encapsulation header before ethernet headers (e.\+g. 802.\+11). Use this if you intend to pass the pbuf to functions like netif-\/$>$linkoutput(). \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group__lwip__opts__pbuf_ga6e1ba1875ae5168a17b53d83597bc1de}{P\+B\+U\+F\+\_\+\+L\+I\+N\+K\+\_\+\+E\+N\+C\+A\+P\+S\+U\+L\+A\+T\+I\+O\+N\+\_\+\+H\+L\+EN}} 
\end{DoxySeeAlso}
\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PBUF\_RAW@{PBUF\_RAW}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!PBUF\_RAW@{PBUF\_RAW}}}\mbox{\Hypertarget{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa21116654fbab6d5a4dfeb87a1bb8f0ba}\label{group__pbuf_ggaee1baa59bb2f85ba575b5a8619ac1ebfa21116654fbab6d5a4dfeb87a1bb8f0ba}} 
P\+B\+U\+F\+\_\+\+R\+AW&Use this for input packets in a netif driver when calling netif-\/$>$input() in the most common case -\/ ethernet-\/layer netif driver. \\
\hline

\end{DoxyEnumFields}


Definition at line 72 of file pbuf.\+h.

\mbox{\Hypertarget{group__pbuf_gab7e0e32fcc292c0d7107721766ed92fb}\label{group__pbuf_gab7e0e32fcc292c0d7107721766ed92fb}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_type@{pbuf\_type}}
\index{pbuf\_type@{pbuf\_type}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_type}{pbuf\_type}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__pbuf_gab7e0e32fcc292c0d7107721766ed92fb}{pbuf\+\_\+type}}}

Enumeration of pbuf types \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{PBUF\_RAM@{PBUF\_RAM}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!PBUF\_RAM@{PBUF\_RAM}}}\mbox{\Hypertarget{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac5e9f28455bca98944a030d4b84ecfab}\label{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac5e9f28455bca98944a030d4b84ecfab}} 
P\+B\+U\+F\+\_\+\+R\+AM&pbuf data is stored in R\+AM, used for TX mostly, struct pbuf and its payload are allocated in one piece of contiguous memory (so the first payload byte can be calculated from struct pbuf). \mbox{\hyperlink{group__pbuf_gacfcb0a2af918658ba0afe36499c65f47}{pbuf\+\_\+alloc()}} allocates P\+B\+U\+F\+\_\+\+R\+AM pbufs as unchained pbufs (although that might change in future versions). This should be used for all O\+U\+T\+G\+O\+I\+NG packets (TX). \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PBUF\_ROM@{PBUF\_ROM}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!PBUF\_ROM@{PBUF\_ROM}}}\mbox{\Hypertarget{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac120b0fe39efe35bb682e4aa3b82e2c9}\label{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac120b0fe39efe35bb682e4aa3b82e2c9}} 
P\+B\+U\+F\+\_\+\+R\+OM&pbuf data is stored in R\+OM, i.\+e. struct pbuf and its payload are located in totally different memory areas. Since it points to R\+OM, payload does not have to be copied when queued for transmission. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PBUF\_REF@{PBUF\_REF}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!PBUF\_REF@{PBUF\_REF}}}\mbox{\Hypertarget{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac9b6ba960fdea6f2e8f35c8313b77e4e}\label{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbac9b6ba960fdea6f2e8f35c8313b77e4e}} 
P\+B\+U\+F\+\_\+\+R\+EF&pbuf comes from the pbuf pool. Much like P\+B\+U\+F\+\_\+\+R\+OM but payload might change so it has to be duplicated when queued before transmitting, depending on who has a \textquotesingle{}ref\textquotesingle{} to it. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PBUF\_POOL@{PBUF\_POOL}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!PBUF\_POOL@{PBUF\_POOL}}}\mbox{\Hypertarget{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbae969347127387b9b59a23ccd24b76d21}\label{group__pbuf_ggab7e0e32fcc292c0d7107721766ed92fbae969347127387b9b59a23ccd24b76d21}} 
P\+B\+U\+F\+\_\+\+P\+O\+OL&pbuf payload refers to R\+AM. This one comes from a pool and should be used for RX. Payload can be chained (scatter-\/gather RX) but like P\+B\+U\+F\+\_\+\+R\+AM, struct pbuf and its payload are allocated in one piece of contiguous memory (so the first payload byte can be calculated from struct pbuf). Don\textquotesingle{}t use this for TX, if the pool becomes empty e.\+g. because of T\+CP queuing, you are unable to receive T\+CP acks! \\
\hline

\end{DoxyEnumFields}


Definition at line 101 of file pbuf.\+h.



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__pbuf_gacfcb0a2af918658ba0afe36499c65f47}\label{group__pbuf_gacfcb0a2af918658ba0afe36499c65f47}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_alloc@{pbuf\_alloc}}
\index{pbuf\_alloc@{pbuf\_alloc}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_alloc()}{pbuf\_alloc()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structpbuf}{pbuf}}$\ast$ pbuf\+\_\+alloc (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__pbuf_gaee1baa59bb2f85ba575b5a8619ac1ebf}{pbuf\+\_\+layer}}}]{layer,  }\item[{u16\+\_\+t}]{length,  }\item[{\mbox{\hyperlink{group__pbuf_gab7e0e32fcc292c0d7107721766ed92fb}{pbuf\+\_\+type}}}]{type }\end{DoxyParamCaption})}

Allocates a pbuf of the given type (possibly a chain for P\+B\+U\+F\+\_\+\+P\+O\+OL type).

The actual memory allocated for the pbuf is determined by the layer at which the pbuf is allocated and the requested size (from the size parameter).


\begin{DoxyParams}{Parameters}
{\em layer} & flag to define header size \\
\hline
{\em length} & size of the pbuf\textquotesingle{}s payload \\
\hline
{\em type} & this parameter decides how and where the pbuf should be allocated as follows\+:\\
\hline
\end{DoxyParams}

\begin{DoxyItemize}
\item P\+B\+U\+F\+\_\+\+R\+AM\+: buffer memory for pbuf is allocated as one large chunk. This includes protocol headers as well.
\item P\+B\+U\+F\+\_\+\+R\+OM\+: no buffer memory is allocated for the pbuf, even for protocol headers. Additional headers must be prepended by allocating another pbuf and chain in to the front of the R\+OM pbuf. It is assumed that the memory used is really similar to R\+OM in that it is immutable and will not be changed. Memory which is dynamic should generally not be attached to P\+B\+U\+F\+\_\+\+R\+OM pbufs. Use P\+B\+U\+F\+\_\+\+R\+EF instead.
\item P\+B\+U\+F\+\_\+\+R\+EF\+: no buffer memory is allocated for the pbuf, even for protocol headers. It is assumed that the pbuf is only being used in a single thread. If the pbuf gets queued, then pbuf\+\_\+take should be called to copy the buffer.
\item P\+B\+U\+F\+\_\+\+P\+O\+OL\+: the pbuf is allocated as a pbuf chain, with pbufs from the pbuf pool that is allocated during pbuf\+\_\+init().
\end{DoxyItemize}

\begin{DoxyReturn}{Returns}
the allocated pbuf. If multiple pbufs where allocated, this is the first pbuf of a pbuf chain. 
\end{DoxyReturn}


Definition at line 248 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga82429084fe29015509c9b4a072707cd4}\label{group__pbuf_ga82429084fe29015509c9b4a072707cd4}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_cat@{pbuf\_cat}}
\index{pbuf\_cat@{pbuf\_cat}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_cat()}{pbuf\_cat()}}
{\footnotesize\ttfamily void pbuf\+\_\+cat (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{h,  }\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{t }\end{DoxyParamCaption})}

Concatenate two pbufs (each may be a pbuf chain) and take over the caller\textquotesingle{}s reference of the tail pbuf.

\begin{DoxyNote}{Note}
The caller M\+AY N\+OT reference the tail pbuf afterwards. Use \mbox{\hyperlink{group__pbuf_ga831c9a72bda1d3bd4c7b96f5a0e3b891}{pbuf\+\_\+chain()}} for that purpose.
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{group__pbuf_ga831c9a72bda1d3bd4c7b96f5a0e3b891}{pbuf\+\_\+chain()}} 
\end{DoxySeeAlso}


Definition at line 840 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga831c9a72bda1d3bd4c7b96f5a0e3b891}\label{group__pbuf_ga831c9a72bda1d3bd4c7b96f5a0e3b891}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_chain@{pbuf\_chain}}
\index{pbuf\_chain@{pbuf\_chain}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_chain()}{pbuf\_chain()}}
{\footnotesize\ttfamily void pbuf\+\_\+chain (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{h,  }\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{t }\end{DoxyParamCaption})}

Chain two pbufs (or pbuf chains) together.

The caller M\+U\+ST call pbuf\+\_\+free(t) once it has stopped using it. Use \mbox{\hyperlink{group__pbuf_ga82429084fe29015509c9b4a072707cd4}{pbuf\+\_\+cat()}} instead if you no longer use t.


\begin{DoxyParams}{Parameters}
{\em h} & head pbuf (chain) \\
\hline
{\em t} & tail pbuf (chain) \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The pbufs M\+U\+ST belong to the same packet. 

M\+AY N\+OT be called on a packet queue.
\end{DoxyNote}
The -\/$>$tot\+\_\+len fields of all pbufs of the head chain are adjusted. The -\/$>$next field of the last pbuf of the head chain is adjusted. The -\/$>$ref field of the first pbuf of the tail chain is adjusted. 

Definition at line 882 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga54ac7b116c6f53c704cbf74f35a8b35c}\label{group__pbuf_ga54ac7b116c6f53c704cbf74f35a8b35c}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_coalesce@{pbuf\_coalesce}}
\index{pbuf\_coalesce@{pbuf\_coalesce}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_coalesce()}{pbuf\_coalesce()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structpbuf}{pbuf}}$\ast$ pbuf\+\_\+coalesce (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p,  }\item[{\mbox{\hyperlink{group__pbuf_gaee1baa59bb2f85ba575b5a8619ac1ebf}{pbuf\+\_\+layer}}}]{layer }\end{DoxyParamCaption})}

Creates a single pbuf out of a queue of pbufs.

\begin{DoxyRemark}{Remarks}
\+: Either the source pbuf \textquotesingle{}p\textquotesingle{} is freed by this function or the original pbuf \textquotesingle{}p\textquotesingle{} is returned, therefore the caller has to check the result!
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
{\em p} & the source pbuf \\
\hline
{\em layer} & pbuf\+\_\+layer of the new pbuf\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a new, single pbuf (p-\/$>$next is N\+U\+LL) or the old pbuf if allocation fails 
\end{DoxyReturn}


Definition at line 1229 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_gaba88511dee3df4b631fde691f421320d}\label{group__pbuf_gaba88511dee3df4b631fde691f421320d}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_copy@{pbuf\_copy}}
\index{pbuf\_copy@{pbuf\_copy}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_copy()}{pbuf\_copy()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__infrastructure__errors_gaf02d9da80fd66b4f986d2c53d7231ddb}{err\+\_\+t}} pbuf\+\_\+copy (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p\+\_\+to,  }\item[{const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p\+\_\+from }\end{DoxyParamCaption})}

Create P\+B\+U\+F\+\_\+\+R\+AM copies of pbufs.

Used to queue packets on behalf of the lw\+IP stack, such as A\+RP based queueing.

\begin{DoxyNote}{Note}
You M\+U\+ST explicitly use p = pbuf\+\_\+take(p);

Only one packet is copied, no packet queue!
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em p\+\_\+to} & pbuf destination of the copy \\
\hline
{\em p\+\_\+from} & pbuf source of the copy\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+R\+R\+\_\+\+OK if pbuf was copied E\+R\+R\+\_\+\+A\+RG if one of the pbufs is N\+U\+LL or p\+\_\+to is not big enough to hold p\+\_\+from 
\end{DoxyReturn}


Definition at line 948 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_gac2f1f58fd36042e82af46f5015720899}\label{group__pbuf_gac2f1f58fd36042e82af46f5015720899}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_copy\_partial@{pbuf\_copy\_partial}}
\index{pbuf\_copy\_partial@{pbuf\_copy\_partial}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_copy\_partial()}{pbuf\_copy\_partial()}}
{\footnotesize\ttfamily u16\+\_\+t pbuf\+\_\+copy\+\_\+partial (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{buf,  }\item[{void $\ast$}]{dataptr,  }\item[{u16\+\_\+t}]{len,  }\item[{u16\+\_\+t}]{offset }\end{DoxyParamCaption})}

Copy (part of) the contents of a packet buffer to an application supplied buffer.


\begin{DoxyParams}{Parameters}
{\em buf} & the pbuf from which to copy data \\
\hline
{\em dataptr} & the application supplied buffer \\
\hline
{\em len} & length of data to copy (dataptr must be big enough). No more than buf-\/$>$tot\+\_\+len will be copied, irrespective of len \\
\hline
{\em offset} & offset into the packet buffer from where to begin copying len bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of bytes copied, or 0 on failure 
\end{DoxyReturn}


Definition at line 1015 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_gab0dd696fb4b6bc65e548944584f1738b}\label{group__pbuf_gab0dd696fb4b6bc65e548944584f1738b}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_free@{pbuf\_free}}
\index{pbuf\_free@{pbuf\_free}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_free()}{pbuf\_free()}}
{\footnotesize\ttfamily u8\+\_\+t pbuf\+\_\+free (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p }\end{DoxyParamCaption})}

Dereference a pbuf chain or queue and deallocate any no-\/longer-\/used pbufs at the head of this chain or queue.

Decrements the pbuf reference count. If it reaches zero, the pbuf is deallocated.

For a pbuf chain, this is repeated for each pbuf in the chain, up to the first pbuf which has a non-\/zero reference count after decrementing. So, when all reference counts are one, the whole chain is free\textquotesingle{}d.


\begin{DoxyParams}{Parameters}
{\em p} & The pbuf (chain) to be dereferenced.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of pbufs that were de-\/allocated from the head of the chain.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
M\+U\+ST N\+OT be called on a packet queue (Not verified to work yet). 

the reference counter of a pbuf equals the number of pointers that refer to the pbuf (or into the pbuf). 
\end{DoxyNote}


Definition at line 715 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga6d803d9945bffb7ad97743f2fa503da6}\label{group__pbuf_ga6d803d9945bffb7ad97743f2fa503da6}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_get\_at@{pbuf\_get\_at}}
\index{pbuf\_get\_at@{pbuf\_get\_at}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_get\_at()}{pbuf\_get\_at()}}
{\footnotesize\ttfamily u8\+\_\+t pbuf\+\_\+get\+\_\+at (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p,  }\item[{u16\+\_\+t}]{offset }\end{DoxyParamCaption})}

Get one byte from the specified position in a pbuf W\+A\+R\+N\+I\+NG\+: returns zero for offset $>$= p-\/$>$tot\+\_\+len


\begin{DoxyParams}{Parameters}
{\em p} & pbuf to parse \\
\hline
{\em offset} & offset into p of the byte to return \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
byte at an offset into p OR Z\+E\+RO IF \textquotesingle{}offset\textquotesingle{} $>$= p-\/$>$tot\+\_\+len 
\end{DoxyReturn}


Definition at line 1299 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga2170ccbbb13238380dbb203ee1b85974}\label{group__pbuf_ga2170ccbbb13238380dbb203ee1b85974}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_memcmp@{pbuf\_memcmp}}
\index{pbuf\_memcmp@{pbuf\_memcmp}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_memcmp()}{pbuf\_memcmp()}}
{\footnotesize\ttfamily u16\+\_\+t pbuf\+\_\+memcmp (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p,  }\item[{u16\+\_\+t}]{offset,  }\item[{const void $\ast$}]{s2,  }\item[{u16\+\_\+t}]{n }\end{DoxyParamCaption})}

Compare pbuf contents at specified offset with memory s2, both of length n


\begin{DoxyParams}{Parameters}
{\em p} & pbuf to compare \\
\hline
{\em offset} & offset into p at which to start comparing \\
\hline
{\em s2} & buffer to compare \\
\hline
{\em n} & length of buffer to compare \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
zero if equal, nonzero otherwise (0xffff if p is too short, diffoffset+1 otherwise) 
\end{DoxyReturn}


Definition at line 1362 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga18c164a6e4a24d89ea9eb7571a886448}\label{group__pbuf_ga18c164a6e4a24d89ea9eb7571a886448}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_memfind@{pbuf\_memfind}}
\index{pbuf\_memfind@{pbuf\_memfind}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_memfind()}{pbuf\_memfind()}}
{\footnotesize\ttfamily u16\+\_\+t pbuf\+\_\+memfind (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p,  }\item[{const void $\ast$}]{mem,  }\item[{u16\+\_\+t}]{mem\+\_\+len,  }\item[{u16\+\_\+t}]{start\+\_\+offset }\end{DoxyParamCaption})}

Find occurrence of mem (with length mem\+\_\+len) in pbuf p, starting at offset start\+\_\+offset.


\begin{DoxyParams}{Parameters}
{\em p} & pbuf to search, maximum length is 0x\+F\+F\+FE since 0x\+F\+F\+FF is used as return value \textquotesingle{}not found\textquotesingle{} \\
\hline
{\em mem} & search for the contents of this buffer \\
\hline
{\em mem\+\_\+len} & length of \textquotesingle{}mem\textquotesingle{} \\
\hline
{\em start\+\_\+offset} & offset into p at which to start searching \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0x\+F\+F\+FF if substr was not found in p or the index where it was found 
\end{DoxyReturn}


Definition at line 1404 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_gaf76863707dc02993eae116574b1ea03f}\label{group__pbuf_gaf76863707dc02993eae116574b1ea03f}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_put\_at@{pbuf\_put\_at}}
\index{pbuf\_put\_at@{pbuf\_put\_at}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_put\_at()}{pbuf\_put\_at()}}
{\footnotesize\ttfamily void pbuf\+\_\+put\+\_\+at (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p,  }\item[{u16\+\_\+t}]{offset,  }\item[{u8\+\_\+t}]{data }\end{DoxyParamCaption})}

Put one byte to the specified position in a pbuf W\+A\+R\+N\+I\+NG\+: silently ignores offset $>$= p-\/$>$tot\+\_\+len


\begin{DoxyParams}{Parameters}
{\em p} & pbuf to fill \\
\hline
{\em offset} & offset into p of the byte to write \\
\hline
{\em data} & byte to write at an offset into p \\
\hline
\end{DoxyParams}


Definition at line 1339 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga50abfe830a33a1a47a562febee66015d}\label{group__pbuf_ga50abfe830a33a1a47a562febee66015d}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_realloc@{pbuf\_realloc}}
\index{pbuf\_realloc@{pbuf\_realloc}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_realloc()}{pbuf\_realloc()}}
{\footnotesize\ttfamily void pbuf\+\_\+realloc (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p,  }\item[{u16\+\_\+t}]{new\+\_\+len }\end{DoxyParamCaption})}

Shrink a pbuf chain to a desired length.


\begin{DoxyParams}{Parameters}
{\em p} & pbuf to shrink. \\
\hline
{\em new\+\_\+len} & desired new length of pbuf chain\\
\hline
\end{DoxyParams}
Depending on the desired length, the first few pbufs in a chain might be skipped and left unchanged. The new last pbuf in the chain will be resized, and any remaining pbufs will be freed.

\begin{DoxyNote}{Note}
If the pbuf is R\+O\+M/\+R\+EF, only the -\/$>$tot\+\_\+len and -\/$>$len fields are adjusted. 

May not be called on a packet queue.

Despite its name, pbuf\+\_\+realloc cannot grow the size of a pbuf (chain). 
\end{DoxyNote}


Definition at line 493 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga77f6bbd69e45e542014d9c547c7da74e}\label{group__pbuf_ga77f6bbd69e45e542014d9c547c7da74e}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_ref@{pbuf\_ref}}
\index{pbuf\_ref@{pbuf\_ref}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_ref()}{pbuf\_ref()}}
{\footnotesize\ttfamily void pbuf\+\_\+ref (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p }\end{DoxyParamCaption})}

Increment the reference count of the pbuf.


\begin{DoxyParams}{Parameters}
{\em p} & pbuf to increase reference counter of \\
\hline
\end{DoxyParams}


Definition at line 820 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga6a961522d81f0327aaf4d4ee6d96c583}\label{group__pbuf_ga6a961522d81f0327aaf4d4ee6d96c583}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_skip@{pbuf\_skip}}
\index{pbuf\_skip@{pbuf\_skip}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_skip()}{pbuf\_skip()}}
{\footnotesize\ttfamily struct \mbox{\hyperlink{structpbuf}{pbuf}}$\ast$ pbuf\+\_\+skip (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{in,  }\item[{u16\+\_\+t}]{in\+\_\+offset,  }\item[{u16\+\_\+t $\ast$}]{out\+\_\+offset }\end{DoxyParamCaption})}

Skip a number of bytes at the start of a pbuf


\begin{DoxyParams}{Parameters}
{\em in} & input pbuf \\
\hline
{\em in\+\_\+offset} & offset to skip \\
\hline
{\em out\+\_\+offset} & resulting offset in the returned pbuf \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pbuf in the queue where the offset is 
\end{DoxyReturn}


Definition at line 1131 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_gad1e31e370271335b197272af2724ca85}\label{group__pbuf_gad1e31e370271335b197272af2724ca85}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_take@{pbuf\_take}}
\index{pbuf\_take@{pbuf\_take}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_take()}{pbuf\_take()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__infrastructure__errors_gaf02d9da80fd66b4f986d2c53d7231ddb}{err\+\_\+t}} pbuf\+\_\+take (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{buf,  }\item[{const void $\ast$}]{dataptr,  }\item[{u16\+\_\+t}]{len }\end{DoxyParamCaption})}

Copy application supplied data into a pbuf. This function can only be used to copy the equivalent of buf-\/$>$tot\+\_\+len data.


\begin{DoxyParams}{Parameters}
{\em buf} & pbuf to fill with data \\
\hline
{\em dataptr} & application supplied data buffer \\
\hline
{\em len} & length of the application supplied data buffer\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+R\+R\+\_\+\+OK if successful, E\+R\+R\+\_\+\+M\+EM if the pbuf is not big enough 
\end{DoxyReturn}


Definition at line 1149 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_gae1cf2bf7454ff87ff377b0b2262f9b44}\label{group__pbuf_gae1cf2bf7454ff87ff377b0b2262f9b44}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_take\_at@{pbuf\_take\_at}}
\index{pbuf\_take\_at@{pbuf\_take\_at}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_take\_at()}{pbuf\_take\_at()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__infrastructure__errors_gaf02d9da80fd66b4f986d2c53d7231ddb}{err\+\_\+t}} pbuf\+\_\+take\+\_\+at (\begin{DoxyParamCaption}\item[{struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{buf,  }\item[{const void $\ast$}]{dataptr,  }\item[{u16\+\_\+t}]{len,  }\item[{u16\+\_\+t}]{offset }\end{DoxyParamCaption})}

Same as \mbox{\hyperlink{group__pbuf_gad1e31e370271335b197272af2724ca85}{pbuf\+\_\+take()}} but puts data at an offset


\begin{DoxyParams}{Parameters}
{\em buf} & pbuf to fill with data \\
\hline
{\em dataptr} & application supplied data buffer \\
\hline
{\em len} & length of the application supplied data buffer \\
\hline
{\em offset} & offset in pbuf where to copy dataptr to\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
E\+R\+R\+\_\+\+OK if successful, E\+R\+R\+\_\+\+M\+EM if the pbuf is not big enough 
\end{DoxyReturn}


Definition at line 1193 of file pbuf.\+c.

\mbox{\Hypertarget{group__pbuf_ga839f342803b0cf89049744124c5a98ad}\label{group__pbuf_ga839f342803b0cf89049744124c5a98ad}} 
\index{Packet buffers (PBUF)@{Packet buffers (PBUF)}!pbuf\_try\_get\_at@{pbuf\_try\_get\_at}}
\index{pbuf\_try\_get\_at@{pbuf\_try\_get\_at}!Packet buffers (PBUF)@{Packet buffers (PBUF)}}
\doxysubsubsection{\texorpdfstring{pbuf\_try\_get\_at()}{pbuf\_try\_get\_at()}}
{\footnotesize\ttfamily int pbuf\+\_\+try\+\_\+get\+\_\+at (\begin{DoxyParamCaption}\item[{const struct \mbox{\hyperlink{structpbuf}{pbuf}} $\ast$}]{p,  }\item[{u16\+\_\+t}]{offset }\end{DoxyParamCaption})}

Get one byte from the specified position in a pbuf


\begin{DoxyParams}{Parameters}
{\em p} & pbuf to parse \\
\hline
{\em offset} & offset into p of the byte to return \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
byte at an offset into p \mbox{[}0..0x\+FF\mbox{]} OR negative if \textquotesingle{}offset\textquotesingle{} $>$= p-\/$>$tot\+\_\+len 
\end{DoxyReturn}


Definition at line 1317 of file pbuf.\+c.

